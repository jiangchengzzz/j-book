### 记录一些最近补的基础遗漏点,直接写结论了，需要验证重新写demo

#### 1. typeof null 为object
```
因为null表示一个空对象指针，    所以在写ts的时候，将来需要赋值对象可将其作为初始值
```

#### 2. .tostring()与String()方法的区别
```
1. 用法 aaa.toString 而 String(aaa)
2. String() 可以将 null与undefined 类型转换成字符串直接变成'null'，'undefined'(直接打印String()得到，但不是赋值，后再用typeof检测任然还是null和undefined)，.toString方法直接会报错没有此方法
```
#### 3. parseInt()， parseFloat()与Number()方法的区别
```
Number() 先来
1、如果是Boolean值，true和false值将分别被转换为1和0。
2、如果是数字值，只是简单的传入和返回。
3、如果是null值，返回0。
4、如果是undefined，返回NaN。
5、如果是字符串：
  a.  如果字符串中只包含数字时，将其转换为十进制数值，忽略前导0
  b. 如果字符串中包含有效浮点格式，如“1.1”，将其转换为对应的浮点数字，忽略前导0
  c. 如果字符串中包含有效的十六进制格式，如“0xf”，将其转换为相同大小的十进制数值
  d. 如果字符串为空，将其转换为0
  e. 如果字符串中包含除上述格式之外的字符，则将其转换为NaN
6. 如果是对象，则调用对象的valueOf（）方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString（）方法，然后再依照前面的规则转换返回的字符串值。
```
```
parseInt() 然后
1、如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。转换空字符串也会返回NaN。
2、开头和结尾的空白符允许存在，会被忽略，直到找到第一个非空格字符。
3、如果第一个字符是数字字符，parseInt() 会继续解析第二个字符，直到解析完所有后续字符串或者遇到了一个非数字字符。遇到不能解析的字符和其后的字符都将被忽略。接着返回已经解析的整数部分。
4、parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。
5、基是由parseInt()方法的第二个参数指定的，所以要解析十六进制的值，当然，对二进制、八进制，甚至十进制（默认模式），都可以这样调用parseInt()方法。
```
```
parseFloat() 再来
1、parseFloat是个全局函数,不属于任何对象。
2、如果在解析过程中遇到了正负号(+或-),数字(0-9),小数点,或者科学记数法中的指数(e或E)以外的字符,则它会忽略该字符以及之后的所有字符,返回当前已经解析到的浮点数.
3、字符串首位的空白符会被忽略.如果参数字符串的第一个字符不能被解析成为数字,则parseFloat返回NaN.
4、字符串中第一个小数点是有效的，而第二个小数点就是无效的了，它后面的字符串将被忽略。
5、parseFloat() 只解析十进制，因此它没有第二个参数指定基数的用法
6、如果字符串中包含的是一个可解析为正数的数（没有小数点，或者小数点后都是零），parseFloat() 会返回整数。
```
```
最后
1. Number()的强制类型转换与parseInt()和parseFloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值。如“3.4.5”，用Number()进行强制类型转换将返回NAN, 如果确定字符串值能被完整地转换，Number()将判断是调用parseInt()还是parseFloat()。 
2. parseFloat() 所解析的字符串中第一个小数点是有效的，而parseInt() 遇到小数点会停止解析，因为小数点并不是有效的数字字符。
3. parseFloat() 始终会忽略前导的零，十六进制格式的字符串始终会被转换成0，而parseInt() 第二个参数可以设置基数，按照这个基数的进制来转换。
```